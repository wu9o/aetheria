# icestark 微前端框架深度解析

本文档详细记录了《iceStark 架构设计》一文中的核心知识点，聚焦于 icestark 框架的设计理念、路由机制、通信方案和沙箱策略，为 AI 提供构建面试题的深度物料。

## 1. 核心架构：基座 + 微应用

icestark 遵循经典的“基座 + 微应用”模型。

- **基座应用 (Shell / Framework Application)**:
    - **职责**:
        - 负责应用的整体布局（如顶部导航、侧边栏）。
        - 注册所有微应用，管理它们的路由信息。
        - 根据 URL 变化，负责加载、挂载和卸载微应用。
- **微应用 (Micro-apps)**:
    - **职责**: 实现独立的业务功能。
    - **特点**:
        - **技术栈无关**: 可以是 React, Vue, Angular 或任何其他框架。
        - **独立开发部署**: 拥有独立的代码库和发布流程。
        - **生命周期**: 必须导出 `mount` (挂载) 和 `unmount` (卸载) 两个生命周期函数，供基座应用调用。

## 2. 路由机制

icestark 的路由由基座应用集中管理，核心是 **“路由劫持”**。

- **工作流程**:
    1.  **监听路由变化**:
        - icestark 会监听 `popstate` 和 `hashchange` 事件，以捕获浏览器的前进/后退操作。
        - 同时，它会重写 `window.history.pushState` 和 `window.history.replaceState` 方法，以及 `window.location` 的 `hash` 属性，从而能够捕获所有程序化的路由跳转。
    2.  **匹配微应用**:
        - 当监听到 URL 变化时，icestark 会用新的 URL 路径去匹配在基座中注册的所有微应用的 `path`。
    3.  **应用调度**:
        - **应用间切换**: 如果匹配到了一个新的微应用，icestark 会先调用当前微应用的 `unmount` 方法将其卸载，然后加载新微应用的资源并调用其 `mount` 方法进行挂载。
        - **应用内跳转**: 如果 URL 变化后，匹配到的仍然是当前微应用，则 icestark 不做任何操作，交由微应用内部的路由系统（如 `react-router`）自行处理视图更新。

## 3. 通信方案

icestark 推荐应用间保持轻量通信，并提供了官方的通信库 `@ice/stark-data`。

- **核心机制**: 基于 `window` 对象的全局 **EventBus** 模式。
- **API**:
    - **`store`**: 提供一个全局的状态管理中心，用于在不同应用间 **共享数据**。类似于一个简化的 Redux store。
    - **`event`**: 提供一个全局的事件总线，用于在不同应用间 **发布/订阅事件**，实现解耦的通信。
- **其他方式**: 也可以通过 `LocalStorage`, `Cookie` 等浏览器原生 API 进行简单的信息共享。

## 4. 沙箱隔离策略

icestark 实现了 JS 沙箱和 CSS 隔离方案，以确保应用间的稳定运行。

### a. JavaScript 沙箱

- **核心技术**: **Proxy Sandbox**。
- **实现原理**:
    1.  使用 ES6 `Proxy` 为每个微应用创建一个代理 `window`。
    2.  微应用对全局变量的 **修改** 会被记录下来。
    3.  当微应用被卸载时，沙箱会根据记录 **还原** `window` 对象，确保对全局环境的污染被清除。
- **特殊处理**:
    - **定时器**: `setTimeout` 和 `setInterval` 会被劫持。当微应用卸载时，所有尚未执行的定时器会被自动清除，防止内存泄漏。
    - **事件监听**: 对 `window` 的事件监听 (`addEventListener`) 也会被记录，并在卸载时自动移除。

### b. CSS 隔离

- **核心问题**: 基座应用和微应用、微应用和微应用之间的样式污染。
- **icestark 的策略 (单实例)**: icestark 默认同一时间只渲染一个微应用，因此主要需要解决的是基座和当前微应用之间的样式冲突。
- **推荐方案**:
    1.  **CSS Modules**: 官方最推荐的方案，从根本上避免了类名冲突。
    2.  **CSS 命名约定/前缀**: 约定基座和不同微应用使用不同的 CSS 类名前缀（如基座用 `next-icestark-`，微应用用 `next-micro-`）。
- **实验性方案**:
    - **Shadow DOM**: 提供了最强的隔离性，但存在一些兼容性和实践上的问题（如全局弹窗的挂载、React 事件系统不兼容等），实现成本较高。

### c. 对第三方应用的隔离

- 对于无法控制代码或完全不信任的第三方应用，官方推荐使用 **`iframe`** 作为最简单、最安全的隔离方案。

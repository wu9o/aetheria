# 微前端沙箱 (Sandbox) 技术深度解析

本文档详细记录了《微前端的沙箱设计》一文中的核心知识点，聚焦于 JS 沙箱的必要性以及两种主流沙箱技术——快照沙箱和代理沙箱的实现原理，为 AI 提供构建面试题的深度物料。

## 1. 为什么需要 JS 沙箱？

在微前端架构中，多个独立的微应用会同时运行在一个页面上，它们共享同一个 `window` 对象。这会带来严重的问题：

- **全局变量污染**: 一个微应用可能会无意间修改 `window` 上的全局变量（如 `window.location`, `window.variable`），导致另一个依赖该变量的微应用崩溃。
- **事件冲突**: 如果多个微应用都监听了同一个全局事件（如 `window.onpopstate`），它们之间会相互覆盖，导致路由等功能失灵。
- **样式冲突**: 全局加载的 CSS 样式会相互影响。
- **安全风险**: 无法限制微应用的代码权限，可能存在安全漏洞。

**JS 沙箱** 的核心目标就是为每个微应用提供一个隔离的运行环境，使得微应用“感觉”自己拥有一个独立的全局 `window`，而实际上它所有的操作都被限制在这个沙箱内部，无法影响到真实的全局环境或其他微应用。

## 2. 沙箱实现方案

### 方案一：快照沙箱 (Snapshot Sandbox)

- **核心思想**: 通过记录和还原 `window` 对象的状态来实现隔离。
- **适用场景**: 只能支持 **同一时间只有一个微应用运行** 的场景。
- **实现原理**:
    1.  **激活 (Activate)**:
        - 在微应用挂载 (mount) 之前，遍历当前的 `window` 对象，拍下一份“快照” (snapshot) 并保存。
        - 如果之前这个微应用运行过并留下了状态修改记录 (modifyMap)，则将这些修改恢复到 `window` 上。
    2.  **失活 (Deactivate)**:
        - 在微应用卸载 (unmount) 之后，再次遍历当前的 `window` 对象，与之前拍下的“快照”进行 **diff** 比较。
        - 将所有发生变更的属性（新增、修改、删除）记录到一个“状态修改记录” (modifyMap) 中。
        - 最后，将 `window` 对象 **完全还原** 成“快照”的样子，恢复到一个干净的状态。
- **缺点**:
    - 无法支持多实例共存。
    - 遍历和 diff `window` 对象会带来性能开销。

### 方案二：代理沙箱 (Proxy Sandbox)

- **核心思想**: 利用 ES6 的 `Proxy` 对象，为每个微应用创建一个专属的“代理 `window`”，拦截其对 `window` 的所有操作。这是目前 **最主流、最强大** 的方案。

#### a. 单例代理沙箱 (LegacyProxy Sandbox)

- **适用场景**: 同样只支持 **同一时间只有一个微应用运行**，但性能优于快照沙箱。
- **实现原理**:
    - 创建一个 `fakeWindow` 对象和一个 `Proxy`。
    - **`get` 操作**: 当微应用读取 `window.xxx` 时，直接从真实的 `window` 对象上读取。
    - **`set` 操作**: 当微应用修改 `window.xxx = value` 时：
        - 在 `fakeWindow` 中记录下这个修改（新增或变更）。
        - **同时，这个修改也会被直接应用到真实的 `window` 对象上**。
    - **失活 (Deactivate)**: 当微应用卸载时，根据 `fakeWindow` 中记录的变更历史，将真实的 `window` 对象还原到干净的状态。
- **优点**: 比快照沙箱性能好，因为它只记录变更，无需遍历。
- **缺点**: 依然会污染真实的 `window`，无法支持多实例。

#### b. 多例代理沙箱 (Proxy Sandbox)

- **适用场景**: 支持 **多个微应用同时运行**，互不干扰。
- **实现原理**:
    - 为每个微应用创建一个独立的 `fakeWindow` 对象。
    - 创建一个 `Proxy` 来代理这个 `fakeWindow`。
    - **`get` 操作**:
        1.  当微应用读取 `window.xxx` 时，**优先** 从它自己的 `fakeWindow` 中查找。
        2.  如果 `fakeWindow` 中没有，则向上穿透，从真实的 `window` 对象中查找（这样微应用依然可以使用 `setTimeout`, `document` 等全局 API）。
    - **`set` 操作**:
        - 当微应用修改 `window.xxx = value` 时，这个操作 **只会被应用到它自己的 `fakeWindow` 对象上**，**完全不会触碰到真实的 `window` 对象**。
- **优点**:
    - **完美隔离**: 提供了近乎完美的隔离，`window` 对象永不被污染。
    - **支持多实例**: 每个微应用都在自己的“缸”里运行，可以多个同时激活。
    - **性能好**: 无需在失活时进行还原操作。

## 3. 总结

| 沙箱类型 | 隔离性 | 多实例支持 | 性能 | 兼容性 |
| :--- | :--- | :--- | :--- | :--- |
| **快照沙箱** | 较弱 (依赖还原) | 否 | 差 | 好 |
| **单例代理** | 较弱 (污染全局) | 否 | 中 | 需 `Proxy` |
| **多例代理** | 强 (不污染全局) | 是 | 好 | 需 `Proxy` |

# 微前端 (Micro-Frontends) 架构深度解析

本文档详细记录了《微前端架构》一文中的核心知识点，聚焦于其定义、解决的问题、核心原则以及多种实现方案，为 AI 提供构建面试题的深度物料。

## 1. 背景：单体前端应用的困境 (Monolithic Hell)

随着前端应用日益复杂，传统的单体应用 (Monolithic Application) 架构会遇到一系列瓶颈：

- **维护困难**: 代码库庞大，逻辑耦合严重，新人上手成本高，修改一处可能引发全局问题。
- **开发效率低**: 所有团队在同一个代码库上协作，容易产生冲突，构建和部署流程漫长。
- **技术栈陈旧**: 对整个应用进行技术升级或重构风险巨大，成本高昂，导致团队被迫维护老旧的技术栈。
- **团队协作成本高**: 跨团队协作需要大量沟通，难以实现团队的独立自治。

## 2. 微前端的核心思想

微前端是一种架构风格，其核心思想是将一个大型的、单体的前端应用 **拆分** 成多个更小、更专注、可 **独立交付** 的 **“微应用”**。这些微应用最终在浏览器中被集成起来，共同构成一个完整的、无缝的用户体验。

它借鉴了后端微服务的理念，旨在将前端的“巨石”打碎。

## 3. 微前端的核心原则

- **技术栈无关 (Technology Agnostic)**: 每个微应用都可以自由选择自己的技术栈（React, Vue, Angular 等），主应用（基座）不关心子应用的技术实现。
- **独立开发与部署 (Independent Development & Deployment)**: 每个微应用都有自己独立的代码仓库和 CI/CD 流程，可以独立于其他应用进行开发、测试和部署。
- **团队自治 (Team Autonomy)**: 每个微应用由一个独立的团队端到端负责，从开发到上线维护。

## 4. 主流实现方案

### a. 路由分发式 (Routing-Based)

- **原理**: 主应用（基座）负责整体的路由管理。当 URL 变化时，主应用根据路由规则，判断应该加载并渲染哪个微应用。
- **代表框架**: `single-spa`。
- **优点**: 是目前最主流、最灵活的方案。
- **缺点**: 需要对微应用进行一定的改造，以适配主应用的加载和生命周期管理。

### b. iframe 嵌套

- **原理**: 主应用通过 `<iframe>` 标签来加载和展示微应用。
- **优点**:
    - **天然隔离**: `iframe` 提供了完美的 JS 和 CSS 沙箱隔离，实现简单。
- **缺点**:
    - **体验问题**: URL 不同步，弹窗和遮罩层只能在 `iframe` 内部显示。
    - **通信复杂**: 父子应用通信需要通过 `postMessage`，流程繁琐。
    - **性能开销**: 每个 `iframe` 都是一个完整的浏览器上下文，内存和性能开销较大。

### c. Web Components

- **原理**: 将每个微应用封装成一个标准的 Web Component (Custom Element)。主应用像使用普通 HTML 标签一样使用它们。
- **优点**:
    - **标准原生**: 遵循 W3C 标准，无框架依赖。
    - **自带隔离**: Shadow DOM 提供了 CSS 和事件的隔离。
- **缺点**:
    - 存在一定的兼容性问题和学习成本。

### d. Webpack 5 模块联邦 (Module Federation)

- **原理**: Webpack 5 的一个革命性功能，允许一个 JS 应用在运行时动态地加载另一个独立部署的 JS 应用中的代码。
- **优点**:
    - **代码共享**: 可以非常灵活地在不同微应用之间共享组件、库等代码。
    - **去中心化**: 不再有严格的“主应用”和“微应用”之分，任何应用都可以消费其他应用暴露的模块。
- **缺点**: 强依赖 Webpack 5，配置相对复杂。

## 5. 微前端的关键挑战：隔离与沙箱

为了保证多个微应用能在一个页面上和谐共存，必须解决它们之间的冲突问题。

- **CSS 隔离**:
    - **目标**: 防止不同微应用的样式相互污染。
    - **方案**:
        - **CSS Modules / Scoped CSS**: 编译时为 CSS 类名添加唯一哈希。
        - **BEM**: 命名约定。
        - **Shadow DOM**: 提供真正的样式隔离。
        - **动态样式表**: 在加载/卸载微应用时，动态地添加/移除其 `<style>` 标签。

- **JS 隔离 (沙箱)**:
    - **目标**: 防止不同微应用污染全局 `window` 对象。
    - **方案**:
        - **快照沙箱 (Snapshot Sandbox)**: 在微应用加载前，为 `window` 拍一个快照；卸载后，根据快照恢复 `window` 对象。适用于同一时间只有一个微应用运行的场景。
        - **代理沙箱 (Proxy Sandbox)**: 使用 ES6 的 `Proxy` 对象，为每个微应用创建一个“假的” `window` 代理。微应用对 `window` 的所有操作都被这个代理拦截，只在代理对象内部生效，不会影响真实的 `window`。这是目前最主流的方案。

# Islands (孤岛) 架构深度解析

本文档详细记录了《了解 Islands 架构》一文中的核心知识点，聚焦于其核心思想、解决的问题、与传统架构的对比以及关键概念，为 AI 提供构建面试题的深度物料。

## 1. 背景：现代前端框架的“ hydration ”成本

- **传统 SSR/SSG 的问题**:
    - 服务器端渲染 (SSR) 或静态站点生成 (SSG) 框架（如 Next.js）虽然能快速返回 HTML 内容，解决了首屏性能和 SEO 问题，但为了让页面可交互，它们需要在客户端执行一个名为 **“注水 (Hydration)”** 的过程。
    - **Hydration**: 浏览器会下载整个页面的 JS 包，重新在内存中构建 VDOM 树，并将事件监听器附加到已存在的 HTML DOM 节点上。
- **过度注水 (Over-hydration)**:
    - **痛点**: 即使页面上只有少数几个需要交互的组件（如一个图片轮播、一个搜索框），传统框架依然会下载和执行 **整个页面** 的 JS 代码。
    - **后果**: 导致 **可交互时间 (TTI - Time to Interactive)** 指标很差。用户虽然能很快看到页面，但需要等待很久才能与之交互。

## 2. Islands 架构的核心思想

Islands 架构旨在解决“过度注水”的问题，其核心理念可以概括为：**静态优先，按需激活**。

- **海洋 (Ocean)**: 整个 HTML 页面默认是 **静态的、不可交互的**，就像一片广阔的海洋。这部分内容由服务器渲染，无需客户端 JS。
- **孤岛 (Island)**: 页面上需要交互的动态区域，就像海洋中的一座座“孤岛”。每个孤岛都是一个独立的组件，它包含了自身的脚本和样式。
- **关键区别**: 传统框架将整个页面视为一个大的交互单元，而 Islands 架构将页面视为由静态 HTML 和多个独立的、可按需激活的动态组件组成。

## 3. 关键概念：渐进式/局部注水 (Progressive/Partial Hydration)

- **定义**: 不再对整个页面进行一次性的注水，而是只对那些需要交互的“孤岛”组件进行独立的、局部的注水。
- **激活时机 (Hydration Triggers)**: 框架（如 Astro）允许开发者精细地控制每个“孤岛”何时加载和执行其 JS 代码。
    - `client:load`: 页面加载时立即激活。
    - `client:idle`: 浏览器空闲时激活。
    - `client:visible`: 当组件进入用户视口时才激活（懒加载）。
    - `client:media`: 满足某个媒体查询条件时激活。
    - `client:only`: 只在客户端渲染，跳过 SSR。

## 4. Islands 架构 vs. 其他架构

| 对比项 | 单页应用 (SPA) | 多页应用 (MPA) | Islands 架构 |
| :--- | :--- | :--- | :--- |
| **渲染主体** | 客户端 | 服务端 | 服务端 (静态 HTML) |
| **JS 负载** | 大，全量加载 | 小，按页加载 | 极小，按需加载 |
| **交互模型** | 整体应用 | 局部脚本 | 独立组件 |
| **页面切换** | 客户端路由，无刷新 | 服务端路由，整页刷新 | 服务端路由，整页刷新 |
| **性能 (TTI)** | 差 | 好 | 极好 |

## 5. 总结

Islands 架构并不是一个新的框架，而是一种架构思想。它通过 **默认静态、按需激活** 的策略，极大地减少了发送到浏览器的 JavaScript 数量，显著优化了网站的 TTI 和核心 Web 指标。它非常适合 **内容驱动型** 的网站（如博客、新闻、电商、文档），这些网站大部分内容是静态展示，只有少量交互区域。

**代表框架**: Astro, Fresh。

# 低代码引擎核心原理深度解析

本文档详细记录了《低代码引擎设计与实现》一文中的核心知识点，聚焦于低代码引擎的三大核心模块、页面描述协议 (Schema) 以及引擎内部的数据流转机制，为 AI 提供构建面试题的深度物料。

## 1. 低代码引擎的核心架构

一个通用的低代码引擎主要由三大模块构成：

1.  **入料模块 (Material)**:
    - **职责**: 负责加载和管理所有“物料”，包括 **组件**、**设置器 (Setter)** 和 **插件 (Plugin)**。
    - **目标**: 将外部的物料资源注册到引擎内部，供设计器使用。

2.  **设计器模块 (Designer)**:
    - **职责**: 提供可视化的页面搭建界面 (画布 Canvas)，是用户进行页面编排的核心区域。
    - **功能**: 支持组件的拖拽、选中、删除、修改层级等操作。
    - **产物**: 用户的可视化操作最终会生成一份 **页面描述协议 (Page Schema)** 的 JSON 数据。

3.  **渲染器模块 (Renderer)**:
    - **职责**: 负责解析 **Page Schema** 并将其渲染成真实的 UI 界面。
    - **特点**: 为了模拟真实的线上环境并避免与设计器模块的样式、逻辑冲突，渲染器通常运行在一个 **隔离的环境** 中（如 `iframe`）。

## 2. 页面描述协议 (Page Schema / DSL)

Schema 是低代码引擎的“通用语言”，是设计器和渲染器之间沟通的桥梁。它是一份用 JSON 格式描述整个页面结构的“图纸”。

- **核心结构**:
    - **`componentName`**: 描述组件的类型，如 `'Button'`, `'Card'`。
    - **`props`**: 描述组件的属性，如 `{ "text": "提交" }`。
    - **`children`**: 描述子节点，通过嵌套形成组件树。
    - **`fileName`**: 描述这是一个组件。
    - **`dataSource`**: 描述组件的数据源。
    - **`lifeCycles`**: 描述组件的生命周期函数。

- **`props` 的特殊值类型**:
    - 除了标准的 JSON 值，Schema 还需要描述一些特殊类型的值：
    - **`JSSlot`**: 用于描述一个 ReactNode 类型的属性（即一个组件插槽）。
    - **`JSFunction`**: 用于描述一个函数类型的属性（如事件回调 `onClick`）。
    - **`JSExpression`**: 用于描述一个动态表达式（如 `state.name`），实现数据绑定。

- **完整的 Schema**:
    - 一个完整的页面 Schema 通常还包括全局信息，如 `utils` (全局工具函数)、`constants` (全局常量)、`css` (全局样式)、`config` (全局配置，如 i18n) 等。

## 3. 渲染器 (Renderer) 的实现

- **沙箱隔离**:
    - 设计器和渲染器运行在不同的 `window` 环境中（通常是父子 `iframe` 关系）。
    - 这种隔离确保了设计器的 UI 和逻辑不会污染最终的渲染效果。
- **通信**:
    - 由于是同源 `iframe`，设计器和渲染器可以相互持有对方的 `window` 引用，直接进行 API 调用。
- **“实时”渲染 (Live Rendering)**:
    1.  当用户在设计器中拖拽或修改属性时，Schema 会发生变化。
    2.  设计器会 **主动调用** 渲染器暴露的 `rerender(schema)` 方法。
    3.  渲染器接收到新的 Schema 后，重新渲染整个画布 `iframe` 内的 UI。
    4.  渲染完成后，渲染器会通知设计器，设计器便可以获取新渲染组件的位置信息，用于高亮、辅助线等功能。

## 4. 设置器 (Setter) 与属性面板

- **设置器 (Setter)**: 是用于在属性面板中编辑特定类型属性的 **UI 控件**。例如，`StringSetter` 是一个输入框，`ColorSetter` 是一个颜色选择器。
- **数据流**:
    1.  **模型转换**: 当用户在画布中选中一个组件时，引擎会将其对应的 Schema 部分转换成一个内部的 **`Node` 模型对象**，方便进行操作。
    2.  **面板渲染**: 属性面板根据 `Node` 对象以及该组件的“组件描述协议”，动态地渲染出对应的 Setter 列表。
    3.  **数据更新**: 当用户在 Setter 中修改一个值时：
        - Setter 会调用 `Node` 对象的方法来更新其内部的 Schema。
        - `Node` 对象的变更会触发一个事件。
    4.  **画布重绘**: 设计器监听到 `Node` 变更事件后，将更新后的完整 Schema 发送给渲染器，触发画布的重新渲染。

## 5. 整体数据流总结

1.  **初始化**: 引擎加载物料（组件、Setter）。
2.  **拖拽**: 用户从物料面板拖拽组件到画布。
3.  **Schema 变更**: 设计器更新 Page Schema。
4.  **渲染**: 设计器将新 Schema 发送给渲染器，渲染器在 `iframe` 中渲染 UI。
5.  **选中**: 用户点击画布中的组件。
6.  **属性面板**: 设计器根据选中组件的 Schema，渲染出属性面板和对应的 Setter。
7.  **修改**: 用户通过 Setter 修改属性。
8.  **Schema 再次变更**: Setter 更新组件的 Schema。
9.  **重绘**: 设计器监听到变更，再次将新 Schema 发送给渲染器，画布更新。

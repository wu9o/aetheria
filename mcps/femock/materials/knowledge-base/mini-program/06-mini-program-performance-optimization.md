# 小程序性能优化深度解析

本文档详细记录了《小程序性能优化》一文中的核心知识点，系统性地梳理了小程序启动性能和运行时性能的优化策略，为 AI 提供构建面试题的深度物料。

## 1. 性能指标

小程序的性能优化主要围绕两大核心场景：

1.  **启动性能 (Startup Performance)**: 用户从点击小程序到看到首屏页面的速度。这是决定用户留存的关键第一印象。
2.  **运行时性能 (Runtime Performance)**: 用户在使用小程序过程中的流畅度，包括页面切换、滚动、动画等交互的响应速度。

## 2. 启动性能优化

启动过程可细分为 **代码包加载** -> **代码注入** -> **首次渲染** 三个阶段。

### a. 代码包加载优化

- **核心目标**: 减小主包体积。
- **策略**:
    1.  **分包加载 (Subpackaging)**:
        - **主包**: 只包含启动页或 TabBar 页面和公共代码。
        - **分包**: 承载独立的业务模块，按需加载。
        - **独立分包**: 可以独立于主包运行的分包，适用于活动页等场景。
    2.  **分包预下载**: 在用户进入可能跳转到分包的页面时，提前在后台下载好对应的分包资源。
    3.  **静态资源优化**:
        - **图片/音视频**: 存放到 CDN，不要直接打包到代码包中。
        - **小图标**: 可以使用雪碧图或字体图标，避免 Base64 编码增加 JS 文件体积。
    4.  **代码清理**: 定期移除无用代码、组件和依赖库。

### b. 代码注入优化

- **核心目标**: 减少 JS 引擎解析和执行代码的时间。
- **策略**:
    1.  **按需注入**: 框架优化，启动时只注入当前页面必需的代码。
    2.  **用时注入**: 框架优化，自定义组件在即将被渲染时才进行 JS 代码注入。
    3.  **减少启动时的同步 API 调用**: `onLaunch` 和 `onLoad` 中的同步操作（如 `wx.getSystemInfoSync`）会阻塞后续流程，应尽量避免或后置。

### c. 首次渲染优化

- **核心目标**: 尽快展示首屏内容 (FCP - First Contentful Paint)。
- **策略**:
    1.  **初始渲染缓存**: 利用框架的缓存机制，在非首次打开时，直接使用缓存的 DOM 结构进行渲染，无需等待逻辑层初始化。
    2.  **数据预请求**: 在 `onLoad` 甚至更早的阶段就发起首屏所需的网络请求。
    3.  **请求结果缓存**: 将首次请求的数据通过 `wx.setStorage` 存入本地。下次打开时，先用缓存数据渲染页面，再发起网络请求更新数据，实现“先渲染后更新”。
    4.  **骨架屏 (Skeleton Screen)**: 使用骨架屏作为 loading 状态，提升用户等待期的体验。
    5.  **精简首屏数据**: `data` 对象中只应包含与首次渲染相关的字段，非渲染数据不要放在 `data` 中。

## 3. 运行时性能优化

### a. `setData` 专项优化

`setData` 是运行时性能的核心瓶颈，必须谨慎使用。
- **优化原则**:
    1.  **数据量**: 只传 **变更** 的、且 **与渲染相关** 的数据。
    2.  **频率**: 避免在短时间内（如 100ms 内）高频调用，善用 **防抖** 和 **节流**。
    3.  **路径**: 使用数据路径精确更新，如 `this.setData({ 'list[0].name': 'new name' })`，而不是更新整个 `list`。
    4.  **范围**: 对于需要高频更新的 UI（如倒计时），将其封装成独立组件，将 `setData` 的影响范围限制在组件内部。
    5.  **后台页面**: 页面 `onHide` 后，必须停止所有 `setData` 调用。

### b. 渲染性能与交互优化

- **长列表优化**:
    - 使用官方提供的 `recycle-view` 组件或虚拟列表技术，只渲染视口内的列表项。
- **动画优化**:
    - **优先 CSS 动画**: 性能最好。
    - **WXS 响应事件**: 对于需要跟随手势的复杂动画，使用 WXS (WeiXin Script)。WXS 运行在渲染层，可以直接操作样式，避免了逻辑层与渲染层之间的通信开销。
    - **避免 JS 动画**: 绝对避免通过 `setInterval` + `setData` 的方式实现动画。
- **节点查询优化**:
    - 避免在 `onPageScroll` 中频繁调用 `SelectorQuery.select(...).boundingClientRect()` 来获取节点位置。
    - 应使用 **`IntersectionObserver`** 来判断节点是否进入视口。
- **WXML 结构优化**:
    - 保持 DOM 结构扁平，避免过深的嵌套。建议节点数少于 1000，深度小于 30 层。

### c. 页面切换优化

- **`onHide`/`onUnload` 清理**: 不要在这些生命周期中执行耗时过长的同步操作，否则会阻塞新页面的跳转。
- **新页面数据预加载**: 在 `wx.navigateTo` 的 `events` 参数中，可以利用 `EventChannel` 提前为下一个页面请求数据，实现“数据等待页面”。

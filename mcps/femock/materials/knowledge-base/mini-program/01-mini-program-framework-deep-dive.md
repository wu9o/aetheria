# 小程序框架原理深度解析

本文档详细记录了《双线程架构》一文中的核心知识点，聚焦于小程序的双线程模型、组件系统、通信机制和生命周期，为 AI 提供构建面试题的深度物料。

## 1. 核心架构：双线程模型

为了兼顾性能、安全和管控，小程序设计了一套独特的 **双线程模型**，将 **逻辑层 (Logic Layer)** 和 **渲染层 (Render Layer)** 彻底分离。

### a. 逻辑层 (Logic Layer)

- **运行环境**: 一个独立的 JavaScript 引擎线程（通常是 JSCore，在 Android 上也可能是 V8）。
- **职责**:
    - 运行开发者的所有业务逻辑 JavaScript 代码。
    - 进行数据处理、网络请求等。
- **限制**:
    - **无 `window` 和 `document` 对象**: 出于安全和管控的考虑，逻辑层无法访问任何 DOM 或 BOM API。这意味着开发者不能像在 Web 中那样直接操作 UI。

### b. 渲染层 (Render Layer)

- **运行环境**: 一个或多个独立的 WebView 线程。
- **职责**:
    - 负责渲染 WXML 和 WXSS，展示用户界面。
- **特点**:
    - **多 WebView**: 通常，小程序的每个页面都会运行在自己的 WebView 中，这有助于页面间切换的流畅性和隔离性。

### 双线程模型的优势

- **性能**: 将耗时的 JS 计算与 UI 渲染分离，避免了 JS 阻塞渲染，保证了界面的流畅响应。
- **安全与管控**: 隔离了 JS 对 DOM 的直接操作，使得平台方可以更好地控制小程序的行为，防止恶意代码。

## 2. 线程间通信机制

逻辑层和渲染层无法直接通信，所有的数据交换都必须通过 **原生 App (如微信) 作为中间层** 进行转发。

- **核心 API**: `this.setData()`
- **工作流程 (数据驱动 UI)**:
    1.  **逻辑层**: 开发者在 Page 的 JS 文件中调用 `this.setData({ key: value })` 来更新数据。
    2.  **数据传递**:
        - `setData` 会将需要更新的数据打包。
        - 通过平台提供的 JSBridge，将数据从 JS 逻辑线程发送给原生层。
    3.  **原生层转发**: 原生层接收到数据后，再将数据转发给对应的 WebView（渲染层）。
    4.  **渲染层**: WebView 内部的 JS 基础库接收到新数据后，会执行一个类似 Virtual DOM Diff 的过程，计算出最小的 DOM 变更，并更新界面。

- **性能瓶颈**:
    - 整个通信链路（JS -> Native -> WebView）较长，且涉及跨线程的数据序列化和反序列化，因此 **频繁或大量地调用 `setData` 会引发性能问题**。

## 3. 组件系统：Exparser

- **定义**: 小程序自研的一套底层组件框架，用于支撑整个 UI 的构建。
- **模型**: 基于 Web Components 的 Shadow DOM 模型，但在纯 JS 环境中实现，不依赖浏览器的原生支持。
- **特点**:
    - **性能**: Exparser 在组件实例的创建、属性传递和事件分发等方面都做了深度优化，即使在页面包含大量组件时也能保持较好的性能。
    - **跨平台**: 由于是 JS 实现，它可以在逻辑层和渲染层中同时运行，为两边都提供了组件化的概念。

## 4. 生命周期 (Lifecycle)

小程序提供了丰富的生命周期钩子函数，方便开发者在不同阶段执行代码。

- **应用生命周期 (`App`)**:
    - `onLaunch`: 小程序初始化完成时触发（全局只触发一次）。
    - `onShow`: 小程序启动，或从后台进入前台显示时。
    - `onHide`: 小程序从前台进入后台时。

- **页面生命周期 (`Page`)**:
    - `onLoad`: 页面加载时触发，一个页面只加载一次。
    - `onShow`: 页面显示/切入前台时。
    - `onReady`: 页面初次渲染完成时。
    - `onHide`: 页面隐藏/切入后台时。
    - `onUnload`: 页面卸载时。

## 5. 新一代渲染引擎：Skyline

为了解决 WebView 渲染的性能瓶颈，官方推出了名为 Skyline 的新一代渲染引擎。

- **核心变革**:
    - **更接近原生**: 采用更高效的渲染管线，绕过了 WebView 的一些限制。
    - **资源共享**: 不同页面之间可以共享更多的渲染资源，降低了内存开销。
    - **通信优化**: 框架自身的通信不再依赖 JSBridge，效率更高。
- **优势**: 提供了更强大的动画系统、手势处理和长列表性能，整体体验更接近原生。
- **使用**: 开发者可以按页面选择性地开启 Skyline 渲染模式，实现渐进式迁移。

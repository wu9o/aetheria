# React Native 架构深度解析

本文档详细记录了《RN 新架构》一文中的核心知识点，聚焦于 React Native 的新旧两代架构的原理、差异、优缺点，为 AI 提供构建面试题的深度物料。

## 1. React Native (RN) 核心定位

RN 是一个允许开发者使用 JavaScript 和 React 来构建原生移动应用的框架。其核心理念是 **"Learn once, write anywhere"**，旨在复用同一套技术栈，同时提供接近原生的性能和体验。

## 2. 旧架构 (Old Architecture)

旧架构是 RN 早期成功的基石，其核心在于三大线程和一个通信桥梁。

### 2.1 三大线程

1.  **JS Thread (JavaScript 线程)**:
    - **职责**: 运行所有的 JS 代码，包括 React 的生命周期、业务逻辑、事件处理等。
    - **环境**: 通常是一个独立的 JavaScriptCore 引擎实例。

2.  **Native Thread (原生主线程 / UI 线程)**:
    - **职责**: 负责原生 UI 的渲染、用户手势响应等。这是 App 的主线程。

3.  **Shadow Thread (布局线程)**:
    - **职责**: 专门用于计算 UI 布局。它使用一个名为 **Yoga** 的 C++ 布局引擎，将 Flexbox 布局转换为原生的 UI 布局信息。
    - **产物**: 生成一个“影子树 (Shadow Tree)”，它是一个纯粹描述布局的 C++ 对象树。

### 2.2 核心瓶颈：The Bridge (通信桥)

- **定义**: Bridge 是 JS 线程与 Native 线程之间通信的唯一通道。
- **工作原理**:
    1.  JS 线程需要更新 UI 或调用原生 API 时，会将指令和数据 **序列化** 成 JSON 字符串。
    2.  通过 Bridge 将这个字符串 **异步** 发送给 Native 线程。
    3.  Native 线程接收到字符串后，**反序列化**，并执行相应的原生操作。
- **三大缺陷**:
    1.  **异步 (Asynchronous)**: 所有通信都是异步的，无法进行同步调用。这使得一些需要立即获取原生布局信息的操作变得困难，也可能导致 UI 更新的延迟。
    2.  **阻塞 (Bridge is congested)**: Bridge 是一条“单行道”。如果 JS 线程和 Native 线程之间有大量、高频的通信（如快速滚动列表），Bridge 就会变得拥堵，导致消息积压和处理延迟，最终引发界面卡顿。
    3.  **开销 (Extra cost)**: 数据的序列化和反序列化过程本身会消耗时间和计算资源，增加了通信的开销。

## 3. 新架构 (New Architecture)

为了解决旧架构的性能瓶颈，RN 推出了革命性的新架构，主要由 JSI, Turbo Modules, 和 Fabric 三部分组成。

### 3.1 JSI (JavaScript Interface)

- **定义**: JSI 是一个用 C++ 编写的轻量级、通用的接口层，它 **取代了 Bridge**。
- **核心变革**:
    - **同步调用**: JSI 允许 JS 和 Native 之间进行 **直接、同步** 的方法调用。
    - **共享引用**: JS 对象可以直接持有对 Native (C++) 对象的引用，反之亦然。这意味着不再需要序列化/反序列化数据，可以直接在两个世界之间传递和操作对象。
    - **与 JS 引擎解耦**: JSI 是一套标准接口，使得 RN 可以轻松地切换不同的 JS 引擎（如 V8, Hermes）。
- **意义**: JSI 从根本上解决了 Bridge 的三大缺陷，是整个新架构的基石。

### 3.2 Turbo Modules

- **定义**: 新一代的原生模块。
- **核心改进**:
    - **懒加载**: 只有当模块第一次被 JS 代码 `require` 时，它才会被 Native 端真正加载和初始化。旧架构中所有原生模块在 App 启动时就需要全部加载。
    - **效果**: 显著减少了 App 的启动时间。

### 3.3 Fabric

- **定义**: 新一代的渲染系统。
- **核心改进**:
    - **JSI 直连**: Fabric 的 UI 操作可以直接通过 JSI 同步地调用到 Native 端，绕过了旧的 Bridge 异步消息队列。
    - **并发渲染**: 支持 React 18 的并发特性（Concurrent Rendering），使得 UI 渲染可以被中断和恢复，提高了复杂页面的响应性。
    - **Shadow Tree 优化**: Shadow Tree 的创建现在可以在 C++ 层同步完成，减少了跨线程的开销。

## 4. 总结对比

| 特性 | 旧架构 | 新架构 |
| :--- | :--- | :--- |
| **通信核心** | Bridge | JSI (JavaScript Interface) |
| **通信方式** | 异步消息队列 | 同步直接调用 |
| **数据传递** | JSON 序列化/反序列化 | C++ 对象引用共享 |
| **原生模块** | 启动时全部加载 | Turbo Modules (按需加载) |
| **渲染系统** | Legacy Renderer | Fabric (支持并发) |
| **性能** | 存在瓶颈，易卡顿 | 大幅提升，接近原生 |
| **启动速度** | 较慢 | 更快 |

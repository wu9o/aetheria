# 比特位计数 (Counting Bits - LeetCode #338)

## 问题描述

给你一个整数 `n` ，对于 `0 <= i <= n` 中的每个 `i` ，计算其二进制表示中 **1 的个数** ，返回一个长度为 `n + 1` 的数组 `ans` 作为答案。

**示例:**

- **输入:** `n = 2`
- **输出:** `[0,1,1]`
- **解释:**
  `0 --> 0`
  `1 --> 1`
  `2 --> 10`

- **输入:** `n = 5`
- **输出:** `[0,1,1,2,1,2]`
- **解释:**
  `0 --> 0`
  `1 --> 1`
  `2 --> 10`
  `3 --> 11`
  `4 --> 100`
  `5 --> 101`

## 要求

- 可以在 O(n) 的时间复杂度内解决。

## 解题代码 (JavaScript) - 动态规划

```javascript
/**
 * @param {number} n
 * @return {number[]}
 */
function countBits(n) {
  // ans[i] 表示整数 i 的二进制表示中 1 的个数
  const ans = new Array(n + 1).fill(0);

  for (let i = 1; i <= n; i++) {
    // 状态转移方程：
    // ans[i] = ans[i >> 1] + (i & 1)
    // i >> 1 是 i 右移一位，相当于 i / 2
    // i & 1  是判断 i 的最低位是 0 还是 1
    // 一个数的二进制1的个数，等于它右移一位的数的1的个数，
    // 再加上它最低位是否为1。
    ans[i] = ans[i >> 1] + (i & 1);
  }

  return ans;
}

// --- 示例 ---
// const n = 5;
// console.log(countBits(n)); // [0,1,1,2,1,2]
```
